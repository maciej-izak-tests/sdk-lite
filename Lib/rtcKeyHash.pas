{
  @html(<b>)
  RTC Key, Lock & Hash digest generator
  @html(</b>)
  - Copyright 2004-2017 (c) RealThinClient.com (http://www.realthinclient.com)
  @html(<br><br>)
}
unit rtcKeyHash;

interface

{$INCLUDE rtcDefs.inc}

uses
  SysUtils,

  rtcTypes,
  rtcInfo,
  rtcFastStrings;

const
  MAX_RTCKEYLOCK_LENGTH = 26*3+1;
  LengthOfMD5Code4Bit = 32;
  LengthOfMD5Code5Bit = 26;
  LengthOfMD5Code6Bit = 22;
  LengthOfMD5Code8Bit = 16;
  LengthOfSHA1Digest = 20;

{ Create a SHA-1 hash digest (length=20) from "M" }
function SHA1_Digest(const M: RtcByteArray):RtcByteArray; overload;

{ Create a SHA-1 hash digest (length=20) from "M" }
function SHA1_Digest(const M: RtcString):RtcString; overload;

{ Create a standard MD5 hash digest (length=32) from "M",
  encoded using 4 bits per character ('0'-'9' and 'a'-'f') }
function MD5Code4Bit(const M: RtcString):RtcString;

{ Create a 5bit-coded MD5 hash digest (length=26) from "M",
  safe for use in HTML and URLs (only contains alpha-numerics),
  encoded using 5 bits per character ('0'-'9' and 'a'-'z') }
function MD5Code5bit(const M: RtcString):RtcString;

{ Create a 6bit-coded MD5 hash digest (length=22) from "M",
  safe for use in HTML and URLs (does not contain reserved HTML characters)
  but NOT safe for use in File names (case sensitive),
  encoded using 6 bits per character ('0'-'9', 'a'-'z', 'A'-'Z', '@' and '$') }
function MD5Code6bit(const M: RtcString):RtcString;

{ Create a Binary-coded MD5 hash digest (length=16) from "M",
  encoded using 8 bits per character (#0 - #255) }
function MD5Code8bit(const M: RtcString):RtcString;

{ Generate a New, Unique Key.
  RndLen = number of random characters to generate for "salt";
           if 0, "salt" will NOT be used and the Key will be smaller.
  Prefix = prefix to use as part of the main key and "salt".
  Big = if TRUE, returns a bigger Key using 2 GUIDs (79 or 53 characters);
        if FALSE, returns a smaller Key using 1 GUID (53 or 27 chars).
  Result = Key starting with "K" and containing the Key code (0..9, A..Z).

  NOTE: Except for the starting "K" character in the Key and "L" character in the "Lock" code,
           the Key and Lock codes do NOT contain any other instances of "K" or "L" characters.
           This makes it possible to concatenate multiple Keys and Locks into a single string
           ready for transfer and storage, without using additional "envelopes" or formats. }
function rtcGenerateKey(const Prefix:RtcString; RndLen:integer; Big:boolean):RtcString;

{ Calculate Lock from Key.
  Key = Key containing the code generated using "rtcGenerateKey".
  Result = Lock starting with "L" and containing the Lock code (0..9, A..Z) }
function rtcCalculateLock(const Key: RtcString): RtcString;

{ Calculate a Public Key from a Prefix (free text), which can be
  used by all Clients as a Public Channel (for example: "Lobby").
  Public Keys do NOT have a "Lock", they are exactly 26 characters 
  long and do NOT contain any instances of "K" or "L" characters.
  Public Keys do NOT contain random charactes, but are calculated
  to always generate the exact same "Key" from the same "Prefix".  }
function rtcMakePublicKey(const Prefix:RtcString):RtcString;

{ Is this a PUBLIC Key (not used with a Lock) ? }
function rtcKeyPublic(const Key: RtcString):boolean;

{ Is "Key" valid (could have been generated by rtcGenerateKey or rtcMakePublicKey)? }
function rtcKeyValid(const Key: RtcString):boolean;

{ Is "Lock" valid (could have been generated by rtcCalculateLock)? }
function rtcLockValid(const Lock: RtcString):boolean;

{ Does the "Key" match the "Lock"? }
function rtcKeyLockMatch(const Key,Lock:RtcString):boolean;

{ Does the "Key" match a MD5Code8Bit encoded "Lock"? }
function rtcKeyMD5Code8BitLockMatch(const Key,MD5Code8BitLock:RtcString):boolean;

implementation

{$IFDEF RTC_RSA}
uses rtcRSA;
{$ENDIF}

type
	MD5Count = array[0..1] of Cardinal;
	MD5State = array[0..3] of Cardinal;
	MD5Block = array[0..15] of Cardinal;
	MD5CBits = array[0..7] of byte;
	MD5Digest = array[0..15] of byte;
	MD5Buffer = array[0..63] of byte;
  MD5Array = array[0..RtcMaxLongint] of byte;
	MD5Context = record
		State: MD5State;
		Count: MD5Count;
		Buffer: MD5Buffer;
	end;

var
	PADDING: MD5Buffer = (
		$80, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00,
		$00, $00, $00, $00, $00, $00, $00, $00
	);

// Transform State according to first 64 bytes at Buffer
procedure Transform(Buffer: pointer; var State: MD5State);
  var
  	a, b, c, d: Cardinal;
  	Block: ^MD5Block absolute Buffer;
  begin
	a := State[0];
	b := State[1];
	c := State[2];
	d := State[3];

  inc(a, ((b and c) or ((not b) and d)) + Block[ 0] + $d76aa478); a := (a shl 7) or (a shr (32 - 7)) + b;
	inc(d, ((a and b) or ((not a) and c)) + Block[ 1] + $e8c7b756); d := (d shl 12) or (d shr (32 - 12)) + a;
	inc(c, ((d and a) or ((not d) and b)) + Block[ 2] + $242070db); c := (c shl 17) or (c shr (32 - 17)) + d;
	inc(b, ((c and d) or ((not c) and a)) + Block[ 3] + $c1bdceee); b := (b shl 22) or (b shr (32 - 22)) + c;
	inc(a, ((b and c) or ((not b) and d)) + Block[ 4] + $f57c0faf); a := (a shl 7) or (a shr (32 - 7)) + b;
	inc(d, ((a and b) or ((not a) and c)) + Block[ 5] + $4787c62a); d := (d shl 12) or (d shr (32 - 12)) + a;
	inc(c, ((d and a) or ((not d) and b)) + Block[ 6] + $a8304613); c := (c shl 17) or (c shr (32 - 17)) + d;
	inc(b, ((c and d) or ((not c) and a)) + Block[ 7] + $fd469501); b := (b shl 22) or (b shr (32 - 22)) + c;
	inc(a, ((b and c) or ((not b) and d)) + Block[ 8] + $698098d8); a := (a shl 7) or (a shr (32 - 7)) + b;
	inc(d, ((a and b) or ((not a) and c)) + Block[ 9] + $8b44f7af); d := (d shl 12) or (d shr (32 - 12)) + a;
	inc(c, ((d and a) or ((not d) and b)) + Block[10] + $ffff5bb1); c := (c shl 17) or (c shr (32 - 17)) + d;
	inc(b, ((c and d) or ((not c) and a)) + Block[11] + $895cd7be); b := (b shl 22) or (b shr (32 - 22)) + c;
	inc(a, ((b and c) or ((not b) and d)) + Block[12] + $6b901122); a := (a shl 7) or (a shr (32 - 7)) + b;
	inc(d, ((a and b) or ((not a) and c)) + Block[13] + $fd987193); d := (d shl 12) or (d shr (32 - 12)) + a;
	inc(c, ((d and a) or ((not d) and b)) + Block[14] + $a679438e); c := (c shl 17) or (c shr (32 - 17)) + d;
	inc(b, ((c and d) or ((not c) and a)) + Block[15] + $49b40821); b := (b shl 22) or (b shr (32 - 22)) + c;

	inc(a, ((b and d) or (c and (not d))) + Block[ 1] + $f61e2562); a := (a shl 5) or (a shr (32 - 5)) + b;
	inc(d, ((a and c) or (b and (not c))) + Block[ 6] + $c040b340); d := (d shl 9) or (d shr (32 - 9)) + a;
	inc(c, ((d and b) or (a and (not b))) + Block[11] + $265e5a51); c := (c shl 14) or (c shr (32 - 14)) + d;
	inc(b, ((c and a) or (d and (not a))) + Block[ 0] + $e9b6c7aa); b := (b shl 20) or (b shr (32 - 20)) + c;
	inc(a, ((b and d) or (c and (not d))) + Block[ 5] + $d62f105d); a := (a shl 5) or (a shr (32 - 5)) + b;
	inc(d, ((a and c) or (b and (not c))) + Block[10] + $02441453); d := (d shl 9) or (d shr (32 - 9)) + a;
	inc(c, ((d and b) or (a and (not b))) + Block[15] + $d8a1e681); c := (c shl 14) or (c shr (32 - 14)) + d;
	inc(b, ((c and a) or (d and (not a))) + Block[ 4] + $e7d3fbc8); b := (b shl 20) or (b shr (32 - 20)) + c;
	inc(a, ((b and d) or (c and (not d))) + Block[ 9] + $21e1cde6); a := (a shl 5) or (a shr (32 - 5)) + b;
	inc(d, ((a and c) or (b and (not c))) + Block[14] + $c33707d6); d := (d shl 9) or (d shr (32 - 9)) + a;
	inc(c, ((d and b) or (a and (not b))) + Block[ 3] + $f4d50d87); c := (c shl 14) or (c shr (32 - 14)) + d;
	inc(b, ((c and a) or (d and (not a))) + Block[ 8] + $455a14ed); b := (b shl 20) or (b shr (32 - 20)) + c;
	inc(a, ((b and d) or (c and (not d))) + Block[13] + $a9e3e905); a := (a shl 5) or (a shr (32 - 5)) + b;
	inc(d, ((a and c) or (b and (not c))) + Block[ 2] + $fcefa3f8); d := (d shl 9) or (d shr (32 - 9)) + a;
	inc(c, ((d and b) or (a and (not b))) + Block[ 7] + $676f02d9); c := (c shl 14) or (c shr (32 - 14)) + d;
	inc(b, ((c and a) or (d and (not a))) + Block[12] + $8d2a4c8a); b := (b shl 20) or (b shr (32 - 20)) + c;

	inc(a, (b xor c xor d) + Block[ 5] + $fffa3942);	a := (a shl 4) or (a shr (32 - 4)) + b;
	inc(d, (a xor b xor c) + Block[ 8] + $8771f681);	d := (d shl 11) or (d shr (32 - 11)) + a;
	inc(c, (d xor a xor b) + Block[11] + $6d9d6122);	c := (c shl 16) or (c shr (32 - 16)) + d;
	inc(b, (c xor d xor a) + Block[14] + $fde5380c);	b := (b shl 23) or (b shr (32 - 23)) + c;
	inc(a, (b xor c xor d) + Block[ 1] + $a4beea44);	a := (a shl 4) or (a shr (32 - 4)) + b;
	inc(d, (a xor b xor c) + Block[ 4] + $4bdecfa9);	d := (d shl 11) or (d shr (32 - 11)) + a;
	inc(c, (d xor a xor b) + Block[ 7] + $f6bb4b60);	c := (c shl 16) or (c shr (32 - 16)) + d;
	inc(b, (c xor d xor a) + Block[10] + $bebfbc70);	b := (b shl 23) or (b shr (32 - 23)) + c;
	inc(a, (b xor c xor d) + Block[13] + $289b7ec6);	a := (a shl 4) or (a shr (32 - 4)) + b;
	inc(d, (a xor b xor c) + Block[ 0] + $eaa127fa);	d := (d shl 11) or (d shr (32 - 11)) + a;
	inc(c, (d xor a xor b) + Block[ 3] + $d4ef3085);	c := (c shl 16) or (c shr (32 - 16)) + d;
	inc(b, (c xor d xor a) + Block[ 6] + $04881d05);	b := (b shl 23) or (b shr (32 - 23)) + c;
	inc(a, (b xor c xor d) + Block[ 9] + $d9d4d039);	a := (a shl 4) or (a shr (32 - 4)) + b;
	inc(d, (a xor b xor c) + Block[12] + $e6db99e5);	d := (d shl 11) or (d shr (32 - 11)) + a;
	inc(c, (d xor a xor b) + Block[15] + $1fa27cf8);	c := (c shl 16) or (c shr (32 - 16)) + d;
	inc(b, (c xor d xor a) + Block[ 2] + $c4ac5665);	b := (b shl 23) or (b shr (32 - 23)) + c;

	inc(a, (c xor (b or (not d))) + Block[ 0] + $f4292244); a := (a shl 6) or (a shr (32 - 6)) + b;
	inc(d, (b xor (a or (not c))) + Block[ 7] + $432aff97); d := (d shl 10) or (d shr (32 - 10)) + a;
	inc(c, (a xor (d or (not b))) + Block[14] + $ab9423a7); c := (c shl 15) or (c shr (32 - 15)) + d;
	inc(b, (d xor (c or (not a))) + Block[ 5] + $fc93a039); b := (b shl 21) or (b shr (32 - 21)) + c;
	inc(a, (c xor (b or (not d))) + Block[12] + $655b59c3); a := (a shl 6) or (a shr (32 - 6)) + b;
	inc(d, (b xor (a or (not c))) + Block[ 3] + $8f0ccc92); d := (d shl 10) or (d shr (32 - 10)) + a;
	inc(c, (a xor (d or (not b))) + Block[10] + $ffeff47d); c := (c shl 15) or (c shr (32 - 15)) + d;
	inc(b, (d xor (c or (not a))) + Block[ 1] + $85845dd1); b := (b shl 21) or (b shr (32 - 21)) + c;
	inc(a, (c xor (b or (not d))) + Block[ 8] + $6fa87e4f); a := (a shl 6) or (a shr (32 - 6)) + b;
	inc(d, (b xor (a or (not c))) + Block[15] + $fe2ce6e0); d := (d shl 10) or (d shr (32 - 10)) + a;
	inc(c, (a xor (d or (not b))) + Block[ 6] + $a3014314); c := (c shl 15) or (c shr (32 - 15)) + d;
	inc(b, (d xor (c or (not a))) + Block[13] + $4e0811a1); b := (b shl 21) or (b shr (32 - 21)) + c;
	inc(a, (c xor (b or (not d))) + Block[ 4] + $f7537e82); a := (a shl 6) or (a shr (32 - 6)) + b;
	inc(d, (b xor (a or (not c))) + Block[11] + $bd3af235); d := (d shl 10) or (d shr (32 - 10)) + a;
	inc(c, (a xor (d or (not b))) + Block[ 2] + $2ad7d2bb); c := (c shl 15) or (c shr (32 - 15)) + d;
	inc(b, (d xor (c or (not a))) + Block[ 9] + $eb86d391); b := (b shl 21) or (b shr (32 - 21)) + c;

	inc(State[0], a);
	inc(State[1], b);
	inc(State[2], c);
	inc(State[3], d);
  end;

// -----------------------------------------------------------------------------------------------

// Initialize given Context
procedure rtcMD5Init(var Context: MD5Context);
  begin
	with Context do
    begin
		State[0] := $67452301;
		State[1] := $efcdab89;
		State[2] := $98badcfe;
		State[3] := $10325476;
		Count[0] := 0;
		Count[1] := 0;
    FillChar(Buffer,SizeOf(MD5Buffer),#0);
		// ZeroMemory(@Buffer, SizeOf(MD5Buffer));
  	end;
  end;

// Update given Context to include Length bytes of Input
procedure rtcMD5Update(var Context: MD5Context; const Input:pointer; Length: Cardinal);
  var
    Index: Cardinal;
    PartLen: Cardinal;
    I: Cardinal;
    InData: ^MD5Array absolute Input;
  begin
	with Context do
    begin
		Index := (Count[0] shr 3) and $3f;
		inc(Count[0], Length shl 3);
		if Count[0] < (Length shl 3) then inc(Count[1]);
		inc(Count[1], Length shr 29);
	  end;
	PartLen := 64 - Index;
	if Length >= PartLen then
    begin
    Move(InData[0],Context.Buffer[Index],PartLen);
		// CopyMemory(@Context.Buffer[Index], Input, PartLen);
		Transform(@Context.Buffer, Context.State);
		I := PartLen;
		while I + 63 < Length do
      begin
			Transform(@InData[I], Context.State);
			inc(I, 64);
		  end;
		Index := 0;
	  end
  else
    I := 0;
  Move(InData[I],Context.Buffer[Index],Length-I);
	// CopyMemory(@Context.Buffer[Index], @Input[I], Length - I);
  end;

// Finalize given Context, create Digest and zeroize Context
procedure rtcMD5Final(var Context: MD5Context; var Digest: MD5Digest);
  var
  	Bits: MD5CBits;
  	Index: Cardinal;
  	PadLen: Cardinal;
  begin
  Move(Context.Count,Bits,2*4);
	//CopyMemory(@Bits, @Context.Count, 2*4);
	Index := (Context.Count[0] shr 3) and $3f;
	if Index < 56 then PadLen := 56 - Index else PadLen := 120 - Index;
	rtcMD5Update(Context, @PADDING, PadLen);
	rtcMD5Update(Context, @Bits, 8);
  Move(Context.State,Digest,4*4);
	//CopyMemory(@Digest, @Context.State, 4*4);
  end;

// -----------------------------------------------------------------------------------------------

// Create digest of given Message
function rtcMD5String(const M: RtcString): MD5Digest;
  var
  	Context: MD5Context;
    MB: RtcByteArray;
  begin
  MB := RtcStringToBytes(M);
	rtcMD5Init(Context);
	rtcMD5Update(Context, @MB[0], length(MB));
	rtcMD5Final(Context, Result);
  SetLength(MB,0);
  end;

// Create hex representation of given Digest
function rtcMD5Print(D: MD5Digest): RtcString;
  const
	  Digits: array[0..15] of RtcChar =
		  ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
  var
  	I, J: byte;
  begin
	SetLength(Result,32);
  J:=1;
	for I := 0 to 15 do
    begin
    Result[J]:=Digits[(D[I] shr 4) and $0f];
    Result[J+1]:=Digits[D[I] and $0f];
    Inc(J,2);
    end;
  end;

// -----------------------------------------------------------------------------------------------

function MD5Code4Bit(const M: RtcString): RtcString;
  begin
  Result:=rtcMD5Print(rtcMD5String(M));
  end;

function MD5Code5bit(const M: RtcString):RtcString;
  var
    Digest: MD5Digest;
    a: integer;
    i: uint64;
  const
	  Dig: array[0..31] of RtcChar =
		  ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
       'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'v', 'x', 'y', 'z');
  begin
	Digest:=rtcMD5String(M);
  SetLength(Result,26);

  i:=0;
  for a:=7 downto 0 do
    i:=(i shl 8) or Byte(Digest[a]);
  for a:=1 to 13 do
    begin
    Result[a]:=Dig[i and $1f];
    i:=i shr 5;
    end;
    
  i:=0;
  for a:=15 downto 8 do
    i:=(i shl 8) or Byte(Digest[a]);
  for a:=14 to 26 do
    begin
    Result[a]:=Dig[i and $1f];
    i:=i shr 5;
    end;
  end;

function MD5Code6bit(const M: RtcString):RtcString;
  var
    Digest: MD5Digest;
    a: integer;
    i: uint64;
  const
	  Dig: array[0..63] of RtcChar =
		  ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
       'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
       'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
       'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
       'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
       'Y', 'Z', '@', '$');
  begin
	Digest:=rtcMD5String(M);
  SetLength(Result,22);

  i:=0;
  for a:=7 downto 0 do
    i:=(i shl 8) or Byte(Digest[a]);
  for a:=1 to 11 do
    begin
    Result[a]:=Dig[i and $3f];
    i:=i shr 6;
    end;

  i:=0;
  for a:=15 downto 8 do
    i:=(i shl 8) or Byte(Digest[a]);
  for a:=12 to 22 do
    begin
    Result[a]:=Dig[i and $3f];
    i:=i shr 6;
    end;
  end;

function MD5Code8bit(const M: RtcString):RtcString;
  var
    Digest: MD5Digest;
    a: integer;
  begin
	Digest:=rtcMD5String(M);
  SetLength(Result,16);

  for a:=1 to 16 do
    Result[a]:=RtcChar(Digest[a-1]);
  end;

{ Generate a new, unique Key }
function rtcGenerateKey(const Prefix:RtcString; RndLen:integer; Big:boolean):RtcString;
  var
    GUID: TGUID;
    GUIDStr1, GUIDStr2: RtcString;
    RandStr: RtcString;
    i: integer;
  {$IFDEF RTC_RSA}
    rnd: TRtcISAAC;
  {$ENDIF}
  const
	  Dig: array[0..31] of RtcChar =
		  ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
       'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'v', 'x', 'y', 'z');
  begin
  Result:='';
  if CreateGuid(GUID) <> S_OK then Exit;
  GUIDStr1 := RtcString( IntToHex(GUID.D1,8)+
                       IntToHex(GUID.D2,4)+IntToHex(GUID.D3,4)+
                       IntToHex(GUID.D4[0],2)+IntToHex(GUID.D4[1],2)+
                       IntToHex(GUID.D4[2],2)+IntToHex(GUID.D4[3],2)+
                       IntToHex(GUID.D4[4],2)+IntToHex(GUID.D4[5],2)+
                       IntToHex(GUID.D4[6],2)+IntToHex(GUID.D4[7],2) );
  RandStr:='';
  if RndLen>0 then
    begin
  {$IFDEF RTC_RSA}
    rnd:=TRtcISAAC.Create(True);
    try
      for i:=1 to RndLen do
        RandStr:=RandStr+Dig[rnd.random(32)];
    finally
      rnd.Free;
      end;
  {$ELSE}
    for i:=1 to RndLen do
      RandStr:=RandStr+Dig[random(32)];
  {$ENDIF}
    end;

  if Big then
    begin
    if CreateGuid(GUID) <> S_OK then Exit;
    GUIDStr2 := RtcString( IntToHex(GUID.D1,8)+
                         IntToHex(GUID.D2,4)+IntToHex(GUID.D3,4)+
                         IntToHex(GUID.D4[0],2)+IntToHex(GUID.D4[1],2)+
                         IntToHex(GUID.D4[2],2)+IntToHex(GUID.D4[3],2)+
                         IntToHex(GUID.D4[4],2)+IntToHex(GUID.D4[5],2)+
                         IntToHex(GUID.D4[6],2)+IntToHex(GUID.D4[7],2) );
    if RndLen>0 then
      Result:='K'+
              Upper_Case( MD5Code5Bit(GUIDStr1+Prefix) +
                         MD5Code5Bit(GUIDStr2+Prefix) +
                         MD5Code5Bit(RandStr+GUIDStr1+GUIDStr2+RandStr) )
    else
      Result:='K'+
              Upper_Case( MD5Code5Bit(GUIDStr1+Prefix) +
                         MD5Code5Bit(GUIDStr2+Prefix) );
    end
  else
    begin
    if RndLen>0 then
      Result:='K'+
              UpperCase( MD5Code5Bit(GUIDStr1+Prefix) +
                         MD5Code5Bit(RandStr+GUIDStr1+RandStr) )
    else
      Result:='K'+
              UpperCase( MD5Code5Bit(GUIDStr1+Prefix) );
    end;
  end;

function rtcMakePublicKey(const Prefix:RtcString):RtcString;
  begin
  Result:=UpperCase( MD5Code5Bit(Prefix) );
  end;

{ Calculate a Lock from the Key }
function rtcCalculateLock(const Key: RtcString): RtcString;
  var
    i:integer;
    lKey:RtcString;
  begin
  Result:='';
  if (length(Key)<>26*3+1) and
     (length(Key)<>26*2+1) and
     (length(Key)<>26*1+1) then Exit;
  if Up_Case(Key[1])<>'K' then Exit;

  SetLength(lKey,length(Key)-1);
  for i:=2 to length(Key) do
    case Key[i] of
      '0'..'9': lKey[i-1]:=Key[i];
      'a'..'j', // skip K and L
      'm'..'p', // skip Q
      'r'..'v', // skip W
      'x'..'z': lKey[i-1]:=Key[i];
      'A'..'J', // skip K and L
      'M'..'P', // skip Q
      'R'..'V', // skip W
      'X'..'Z': lKey[i-1]:=RtcChar(Ord(Key[i])-Ord('A')+Ord('a'));
      else Exit;
    end;

  if length(lKey)=26*3 then
    Result:='L' + UpperCase (
                MD5Code5Bit( MD5Code4Bit(Copy(lKey, 1,       13*3)) +
                             MD5Code5Bit(Copy(lKey, 1+ 13*1, 13*3)) +
                             MD5Code6Bit(Copy(lKey, 1+ 13*2, 13*3)) +
                             MD5Code8Bit(Copy(lKey, 1+ 13*3, 13*3)) ) +
                MD5Code5Bit( lKey ) +
                Copy(lKey,1 + 13*4,13*2) )
  else if length(lKey)=26*2 then
    Result:='L' + UpperCase (
                MD5Code5Bit( MD5Code4Bit(Copy(lKey, 1,       13*2)) +
                             MD5Code6Bit(Copy(lKey, 1+ 13*1, 13*2)) +
                             MD5Code8Bit(Copy(lKey, 1+ 13*2, 13*2)) +
                             lKey ) +
                Copy(lKey,1 + 13*3,13) )
  else if length(lKey)=26*1 then
    Result:='L' + UpperCase (
                MD5Code5Bit( MD5Code4Bit(Copy(lKey, 1,    19)) +
                             MD5Code6Bit(Copy(lKey, 1+ 7, 19)) +
                             lKey ) );
  end;

function rtcKeyPublic(const Key: RtcString):boolean;
  begin
  Result:=(length(Key)=26) and rtcKeyValid(Key);
  end;

function rtcKeyValid(const Key: RtcString):boolean;
  var
    i:integer;
    ok:boolean;
  begin
  Result:=False;
  ok:=False;
  if (length(Key)=26) then
    begin
    case Key[1] of
      '0'..'9',
      'a'..'j', // skip K and L
      'm'..'p', // skip Q
      'r'..'v', // skip W
      'x'..'z',
      'A'..'J', // skip K and L
      'M'..'P', // skip Q
      'R'..'V', // skip W
      'X'..'Z': ok:=True;
      else Exit;
      end;
    end
  else
    begin
    if (length(Key)<>26*3+1) and
       (length(Key)<>26*2+1) and
       (length(Key)<>26*1+1) then Exit;
    if Up_Case(Key[1])<>'K' then Exit;
    end;
  for i:=2 to length(Key) do
    case Key[i] of
      '0'..'9',
      'a'..'j', // skip K and L
      'm'..'p', // skip Q
      'r'..'v', // skip W
      'x'..'z',
      'A'..'J', // skip K and L
      'M'..'P', // skip Q
      'R'..'V', // skip W
      'X'..'Z': ok:=True;
      else Exit;
    end;
  Result:=ok;
  end;

function rtcLockValid(const Lock: RtcString):boolean;
  var
    i:integer;
    ok:boolean;
  begin
  Result:=False;
  if (length(Lock)<>26*3+1) and
     (length(Lock)<>13*3+1) and
     (length(Lock)<>13*2+1) then Exit;
  if Up_Case(Lock[1])<>'L' then Exit;
  ok:=False;
  for i:=2 to length(Lock) do
    case Lock[i] of
      '0'..'9',
      'a'..'j', // skip K and L
      'm'..'p', // skip Q
      'r'..'v', // skip W
      'x'..'z',
      'A'..'J', // skip K and L
      'M'..'P', // skip Q
      'R'..'V', // skip W
      'X'..'Z': ok:=True;
      else Exit;
    end;
  Result:=ok;
  end;

function rtcKeyLockMatch(const Key,Lock:RtcString):boolean;
  begin
  if rtcKeyPublic(Key) then
    Result:=(Lock=Key)
  else if not (rtcKeyValid(Key) and rtcLockValid(Lock)) then
    Result:=False
  else
    Result := rtcCalculateLock(Key) = Lock;
  end;

function rtcKeyMD5Code8BitLockMatch(const Key,MD5Code8BitLock:RtcString):boolean;
  begin
  if length(MD5Code8BitLock)<>LengthOfMD5Code8Bit then
    Result:=False
  else
    Result := MD5Code8Bit(rtcCalculateLock(Key)) = MD5Code8BitLock;
  end;

type
  TSHA1Word = Cardinal;
  TSHA1Buf = array[0..4] of TSHA1Word;
  TSHA1In = array[0..15] of TSHA1Word;
  TSHA1WArray = array[0..79] of TSHA1Word;
  TSHA1Context = record
    buf: TSHA1Buf;
    bytes: array[0..1] of TSHA1Word;
    in_: TSHA1In;
    W: TSHA1WArray;
  end;
  TSHA1Digest = array[0..19] of Byte;

procedure SHA1Transform(var buf: TSHA1Buf; const in_: TSHA1In; var W: TSHA1WArray); forward;

function ByteSwap(const X: TSHA1Word): TSHA1Word;
begin
  Result :=
    (X shl 24) or
    ((X and $FF00) shl 8) or
    ((X and $FF0000) shr 8) or
    (X shr 24);
end;

(*
* Start SHA-1 accumulation.  Set byte count to 0 and buffer to mysterious
* initialization constants.
*)
procedure SHA1Init(var ctx: TSHA1Context);
begin
  ctx.buf[0] := TSHA1Word($67452301);
  ctx.buf[1] := TSHA1Word($efcdab89);
  ctx.buf[2] := TSHA1Word($98badcfe);
  ctx.buf[3] := TSHA1Word($10325476);
  ctx.buf[4] := TSHA1Word($c3d2e1f0);

  ctx.bytes[0] := 0;
  ctx.bytes[1] := 0;
end;

(*
* Update context to reflect the concatenation of another buffer full
* of bytes.
*)
procedure SHA1Update(var ctx: TSHA1Context; const buffer; len: Cardinal);
var
  buf: ^Byte;
  t: TSHA1Word;
begin
  buf := @buffer;

  { Update byte count }
  t := ctx.bytes[0];
  Inc(ctx.bytes[0], len);
  if Cardinal(ctx.bytes[0]) < Cardinal(t) then
    Inc(ctx.bytes[1]); { Carry from low to high }

  t := 64 - (t and $3f); { Space available in ctx.in (at least 1) }
  if Cardinal(t) > Cardinal(len) then begin
    Move(buf^, Pointer(Cardinal(@ctx.in_) + 64 - t)^, len);
    Exit;
  end;
  { First chunk is an odd size }
  Move(buf^, Pointer(Cardinal(@ctx.in_) + 64 - t)^, t);
  SHA1Transform(ctx.buf, ctx.in_, ctx.W);
  Inc(buf, t);
  Dec(len, t);

  { Process data in 64-byte chunks }
  while Cardinal(len) >= Cardinal(64) do begin
    Move(buf^, ctx.in_, 64);
    SHA1Transform(ctx.buf, ctx.in_, ctx.W);
    Inc(buf, 64);
    Dec(len, 64);
  end;

  { Handle any remaining bytes of data. }
  Move(buf^, ctx.in_, len);
end;

(*
* Final wrapup - pad to 64-byte boundary with the bit pattern
* 1 0* (64-bit count of bits processed, MSB-first)
*)
function SHA1Final(var ctx: TSHA1Context): TSHA1Digest;
var
  count, i: Integer;
  p: ^Byte;
begin
  count := ctx.bytes[0] and $3f; { Number of bytes in ctx.in }
  p := @ctx.in_;
  Inc(p, count);

  { Set the first char of padding to 0x80.  There is always room. }
  p^ := $80;
  Inc(p);

  { Bytes of padding needed to make 56 bytes (-8..55) }
  count := 56 - 1 - count;

  if count < 0 then begin { Padding forces an extra block }
    FillChar(p^, count + 8, 0);
    SHA1Transform(ctx.buf, ctx.in_, ctx.W);
    p := @ctx.in_;
    count := 56;
  end;
  FillChar(p^, count, 0);

  { Append length in bits and transform }
  ctx.in_[15] := ByteSwap(ctx.bytes[0] shl 3);
  ctx.in_[14] := ByteSwap((ctx.bytes[1] shl 3) or (ctx.bytes[0] shr 29));
  SHA1Transform(ctx.buf, ctx.in_, ctx.W);

  for i := 0 to High(ctx.buf) do
    ctx.buf[i] := ByteSwap(ctx.buf[i]);
  Move(ctx.buf, Result, SizeOf(Result));
  FillChar(ctx, SizeOf(ctx), 0); { In case it's sensitive }
end;

(*
* The core of the SHA-1 algorithm, this alters an existing SHA-1 hash to
* reflect the addition of 16 longwords of new data.  SHA1Update blocks
* the data and converts bytes into longwords for this routine.
*)
procedure SHA1Transform(var buf: TSHA1Buf; const in_: TSHA1In; var W: TSHA1WArray);
const
  K1 = $5A827999;
  K2 = $6ED9EBA1;
  K3 = $8F1BBCDC;
  K4 = $CA62C1D6;
var
  t: Integer;
  temp, A, B, C, D, E: TSHA1Word;
begin
  for t := 0 to 15 do begin
    { ByteSwap inlined: }
    temp := in_[t];
    W[t] := (temp shl 24) or
            ((temp and $FF00) shl 8) or
            ((temp and $FF0000) shr 8) or
            (temp shr 24);
  end;

  for t := 16 to 79 do begin
    temp := W[t-3] xor W[t-8] xor W[t-14] xor W[t-16];
    W[t] := (temp shl 1) or (temp shr (32-1));
  end;

  A := buf[0];
  B := buf[1];
  C := buf[2];
  D := buf[3];
  E := buf[4];

  for t := 0 to 19 do begin
    temp := ((A shl 5) or (A shr (32-5))) +
            (D xor (B and (C xor D))) + E + W[t] + K1;
    E := D;
    D := C;
    C := (B shl 30) or (B shr (32-30));
    B := A;
    A := temp;
  end;

  for t := 20 to 39 do begin
    temp := ((A shl 5) or (A shr (32-5))) + (B xor C xor D) + E + W[t] + K2;
    E := D;
    D := C;
    C := (B shl 30) or (B shr (32-30));
    B := A;
    A := temp;
  end;

  for t := 40 to 59 do begin
    temp := ((A shl 5) or (A shr (32-5))) +
            ((B and C) or (B and D) or (C and D)) + E + W[t] + K3;
    E := D;
    D := C;
    C := (B shl 30) or (B shr (32-30));
    B := A;
    A := temp;
  end;

  for t := 60 to 79 do begin
    temp := ((A shl 5) or (A shr (32-5))) + (B xor C xor D) + E + W[t] + K4;
    E := D;
    D := C;
    C := (B shl 30) or (B shr (32-30));
    B := A;
    A := temp;
  end;

  Inc(buf[0], A);
  Inc(buf[1], B);
  Inc(buf[2], C);
  Inc(buf[3], D);
  Inc(buf[4], E);
end;

{ Create a SHA-1 hash digest (length=20) from "M" }
function SHA1_Digest(const M: RtcByteArray):RtcByteArray;
  var
    Context: TSHA1Context;
    Digest: TSHA1Digest;
  begin
  SHA1Init(Context);
  SHA1Update(Context, M[0], length(M));
  Digest := SHA1Final(Context);
  SetLength(Result,SizeOf(Digest));
  Move(Digest,Result[0],length(Result));
  end;

{ Create a SHA-1 hash digest (length=20) from "M" }
function SHA1_Digest(const M: RtcString):RtcString;
  begin
  Result:=RtcBytesToString(SHA1_Digest(RtcStringToBytes(M)));
  end;

end.
